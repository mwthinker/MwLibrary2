#if MW_OPENGLES2
#include "shader.h"
#include "opengl.h"
#include "window.h"

#include <fstream>
#include <sstream>
#include <iostream>
#include <cassert>

namespace mw {

	namespace {

		void checkGlShaderSourceError() {
			GLenum err(glGetError());

			if (err != GL_NO_ERROR) {
				std::string error = "Function glShaderSource caused:\n";

				switch (err) {
					case GL_INVALID_OPERATION:
						error += "GL_INVALID_OPERATION, was generated if a shader compiler was not supported.";
						error += "\nor was generated if shader was not a shader object.";
						break;
					case GL_INVALID_VALUE:
						error += "GL_INVALID_VALUE was generated if shader was not a value generated by OpenGL";
						error += "\nor was generated if count was less than 0.";
						break;
				}

				std::cerr << error.c_str() << std::endl;
			}
		}

		void checkGlCompileShaderError() {
			GLenum err(glGetError());

			if (err != GL_NO_ERROR) {
				std::string error = "Function glShaderSource caused:\n";

				switch (err) {
					case GL_INVALID_OPERATION:
						error += "GL_INVALID_OPERATION, was generated if a shader compiler was not supported";
						error += "\nor was generated if shader was not a shader object.";
						break;
					case GL_INVALID_VALUE:
						error += "GL_INVALID_VALUE was generated if shader was not a value generated by OpenGL";
						break;
				}

				std::cerr << error.c_str() << std::endl;
			}
		}

		void checkGlAttachShaderError() {
			GLenum err(glGetError());

			if (err != GL_NO_ERROR) {
				std::string error = "Function glShaderSource caused:\n";

				switch (err) {
					case GL_INVALID_OPERATION:
						error += "GL_INVALID_OPERATION was generated if program was not a program object.";
						error += "\nwas generated if shader was already attached to program, or if another shader object of the same type as shader was already attached to program.";
						error += "\nor was generated if shader was not a shader object.";
						break;
					case GL_INVALID_VALUE:
						error += "GL_INVALID_VALUE was generated if program or shader was not a value generated by OpenGL";
						break;
				}

				std::cerr << error.c_str() << std::endl;
			}
		}

		GLuint loadShader(GLuint program, GLenum type, const GLchar* shaderSrc) {
			mw::checkGlError();
			GLuint shader= mw::glCreateShader(type);
			
			mw::glShaderSource(shader, 1, &shaderSrc, NULL);
#if _DEBUG
			checkGlShaderSourceError();
#endif // _DEBUG
			mw::glCompileShader(shader);
#if _DEBUG
			checkGlCompileShaderError();
#endif // _DEBUG
			mw::glAttachShader(program, shader);
#if _DEBUG
			checkGlAttachShaderError();			
			GLint infoLen = 0;
			mw::glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);
			if (infoLen > 1) {
				char message[256];
				GLsizei size;
				mw::glGetShaderInfoLog(shader, sizeof(message), &size, message);
				std::string str;
				str.append(message, message + size);
				std::cerr << "\nError loading shader: " << str << std::endl;
			}
#endif // _DEBUG
			return shader;
		}

	}

	Shader::Shader() :
		location_(0),
		programObjectId_(0),
		shaderData_(std::make_shared<ShaderData>()) {

	}

	Shader::ShaderData::ShaderData() :
		location_(0),
		programObjectId_(0),
		windowInstance_(0) {

	}

	Shader::ShaderData::~ShaderData() {
		// Opengl program loaded? And the opengl context active?
		if (programObjectId_ != 0 && windowInstance_ == Window::getInstanceId()) {
			// Is called if the program is valid and therefore need to be cleaned up.
			mw::glDeleteProgram(programObjectId_);
		}
	}

	void Shader::bindAttribute(std::string attribute) {
		if (programObjectId_ == 0) {
			shaderData_->attributes_[attribute] = location_;
		}
	}

	int Shader::getAttributeLocation(std::string attribute) const {
		auto it = shaderData_->attributes_.find(attribute);
		if (it != shaderData_->attributes_.end()) {
			return it->second;
		}
		return -1;
	}

	int Shader::getUniformLocation(std::string uniform) const {
		if (programObjectId_ != 0) {
			auto it = shaderData_->uniforms_.find(uniform);

			if (it != shaderData_->uniforms_.end()) {
				return it->second;
			} else {
				int loc = mw::glGetUniformLocation(programObjectId_, uniform.c_str());
				if (loc != -1) {
					shaderData_->uniforms_[uniform] = loc;
				}
				return loc;
			}
		}
		return -1;
	}

	bool Shader::loadAndLinkFromFile(std::string vShaderFile, std::string fShaderFile) {
		if (programObjectId_ == 0) {
				{
					std::ifstream inFile(vShaderFile);
					std::stringstream stream;
					stream << inFile.rdbuf();
					vShaderFile = stream.str();
				}
			{
				std::ifstream inFile(fShaderFile);
				std::stringstream stream;
				stream << inFile.rdbuf();
				fShaderFile = stream.str();
			}
			return loadAndLink(vShaderFile, fShaderFile);
		}
		return false;
	}

	bool Shader::loadAndLink(std::string vShader, std::string fShader) {
		if (programObjectId_ == 0) {

			programObjectId_ = mw::glCreateProgram();
			shaderData_->programObjectId_ = programObjectId_;
			shaderData_->windowInstance_ = Window::getInstanceId();
			if (programObjectId_ == 0) {
				return false;
			}

			loadShader(programObjectId_, GL_VERTEX_SHADER, vShader.c_str());
			loadShader(programObjectId_, GL_FRAGMENT_SHADER, fShader.c_str());

			// Bind all attributes.
			for (auto& pair : shaderData_->attributes_) {
				mw::glBindAttribLocation(programObjectId_, location_, pair.first.c_str());
				pair.second = location_++;
			}

			mw::glLinkProgram(programObjectId_);

			GLint linked;
			mw::glGetProgramiv(programObjectId_, GL_LINK_STATUS, &linked);
			if (!linked) {
				GLint infoLen = 0;
				mw::glGetProgramiv(programObjectId_, GL_INFO_LOG_LENGTH, &infoLen);
				if (infoLen > 1) {
					char message[256];
					GLsizei size;
					mw::glGetProgramInfoLog(programObjectId_, sizeof(message), &size, message);
					std::string str;
					str.append(message, message + size);
					std::cerr << "Error linking program: " << str << std::endl;
				}
				mw::glDeleteProgram(programObjectId_);
				return false;
			}

			mw::glUseProgram(programObjectId_);
			return true;
		}
		return false;
	}

	void Shader::glUseProgram() const {
		if (programObjectId_ != 0) {
			mw::glUseProgram(programObjectId_);
		}
	}

	Shader Shader::defaultShader;

	const Shader& Shader::getDefaultShader() {
		return defaultShader;
	}

	void Shader::setDefaultShader(const Shader& shader) {
		defaultShader = shader;
	}

} // Namespace mw.

#endif // MW_OPENGLES2
